// lib/data/network/entity/recipe_entity.dart

import 'package:json_annotation/json_annotation.dart';

part 'mtg_card_entity.g.dart';

/* The types of calls that we will be making to the Scryfall database will be general
searches, which will always return a list of card data entries. Here we'll be utilizing
autogenerated code for deserialization, so we'll be generally using the same names.
When we get to the card entity list we're going to utilize @JsonSerializable(fieldRename: FieldRename.snake)
but that isn't required here since there are so few fields. */
@JsonSerializable()
class MtgCardListResponse {
  final String object;
  @JsonKey(name: 'total_cards')
  final int totalCards;
  @JsonKey(name: 'has_more')
  final bool hasMore;
  final List<MtgCardEntity> data;

  MtgCardListResponse({
    required this.object, 
    required this.totalCards,
    required this.hasMore,
    required this.data
  });

  factory MtgCardListResponse.fromJson(Map<String, dynamic> json) =>
      _$MtgCardListResponseFromJson(json);

  Map<String, dynamic> toJson() => _$MtgCardListResponseToJson(this);
}

/* Utility class for deserializing card color data. It comes in as a string array. */
@JsonSerializable(fieldRename: FieldRename.snake, explicitToJson: true)
class ColorsEntity {
  List<String> colors;

  ColorsEntity({
    required this.colors
  });

  factory ColorsEntity.fromJson(Map<String, dynamic> json) =>
      _$ColorsEntityFromJson(json);

  Map<String, dynamic> toJson() => _$ColorsEntityToJson(this);
}

/* Utility class for deserializing card color identity data. It comes in as a string array. 
This data is different than the 'colors' data in ways that I'm not sure. But color data
is important, sortable, and filterable so I'm adding it for figuring out later. */
@JsonSerializable(fieldRename: FieldRename.snake, explicitToJson: true)
class ColorIdentityEntity {
  List<String> colorIdentity;

  ColorIdentityEntity({
    required this.colorIdentity
  });

  factory ColorIdentityEntity.fromJson(Map<String, dynamic> json) =>
      _$ColorIdentityEntityFromJson(json);

  Map<String, dynamic> toJson() => _$ColorIdentityEntityToJson(this);
}

/* Utility class for deserializing format legality data. It comes in as a map object. 
This is very important information that is pretty boilerplate. The main code should have
some sort of occassional update scheme for syncing this information. Maybe something like 
every few months. Probably check it against database 'last updated' info or something. */
@JsonSerializable(fieldRename: FieldRename.snake, explicitToJson: true)
class LegalitiesEntity {
  Map<String, String> legalitites;

  LegalitiesEntity({
    required this.legalitites
  });

  factory LegalitiesEntity.fromJson(Map<String, dynamic> json) =>
      _$LegalitiesEntityFromJson(json);

  Map<String, dynamic> toJson() => _$LegalitiesEntityToJson(this);
}

/* Utility class for deserializing image location data. It comes in as a map object. 
We'll store the links but given the overall philosophy of the program might want to save
all of the PNG files locally. */
@JsonSerializable(fieldRename: FieldRename.snake, explicitToJson: true)
class ImageUriEntity {
  Map<String, String> imageUris;

  ImageUriEntity({
    required this.imageUris
  });

  factory ImageUriEntity.fromJson(Map<String, dynamic> json) =>
      _$ImageUriEntityFromJson(json);

  Map<String, dynamic> toJson() => _$ImageUriEntityToJson(this);
}

/* Each of the card entries in the list returned from Scryfall has a ton of data.
Most of it we don't need, so we'll just take the fields and structures that we do.
Any nested structures we'll also have to define JsonSerializable classes for as well
if we need the data. Otherwise we'll just ignore the fields. */
@JsonSerializable(fieldRename: FieldRename.snake, explicitToJson: true)
class MtgCardEntity {
  final String name;
  final String releasedAt;
  final String manaCost;
  @JsonKey(name: 'cmc')
  final int convertedManaCost;
  final String typeLine;
  final String oracleText;
  final int power;
  final int touchness;
  ColorsEntity colors;
  ColorIdentityEntity colorIdentity;
  LegalitiesEntity legalities;
  ImageUriEntity imageUris;
  final String set;
  final String rarity;

  MtgCardEntity({
    required this.name,
    required this.releasedAt,
    required this.manaCost,
    required this.convertedManaCost,
    required this.typeLine,
    required this.oracleText,
    required this.power,
    required this.touchness,
    required this.colors,
    required this.colorIdentity,
    required this.legalities,
    required this.imageUris,
    required this.set,
    required this.rarity
  });

  factory MtgCardEntity.fromJson(Map<String, dynamic> json) =>
      _$MtgCardEntityFromJson(json);
}
